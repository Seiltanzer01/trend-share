<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wall Street 3D Platformer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Press Start 2P', cursive; }
    canvas { display: block; }
    /* Оверлей мини-игры (для угадывания направления графика) */
    #minigame-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      display: none;
      z-index: 10;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #minigame-overlay canvas {
      border: 2px solid #fff;
      margin-bottom: 20px;
    }
    .minigame-btn {
      padding: 10px 20px;
      margin: 5px;
      background: #27ae60;
      border: none;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
    }
    @media (max-width: 480px) {
      .minigame-btn { font-size: 14px; padding: 8px 16px; }
    }
  </style>
  <!-- Three.js и GLTFLoader -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- PointerLockControls для управления от первого лица (мы будем адаптировать для третьего лица) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
  <!-- Контейнер для рендеринга 3D-сцены -->
  <div id="game-container"></div>
  <!-- Оверлей для мини-игры (график свечей) -->
  <div id="minigame-overlay">
    <h2>Guess the Market Direction!</h2>
    <canvas id="chartCanvas" width="300" height="200"></canvas>
    <div>
      <button class="minigame-btn" id="btnUp">UP</button>
      <button class="minigame-btn" id="btnDown">DOWN</button>
    </div>
  </div>

  <script>
    // Глобальные переменные
    let scene, camera, renderer, controls;
    let player, terminal;
    let clock = new THREE.Clock();
    let moveSpeed = 5;
    let keys = {};
    let gamePaused = false;

    // Инициализация сцены
    init();
    animate();

    function init() {
      // Сцена
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x000000, 20, 100);

      // Камера (третьего лица)
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 4, 10);

      // Рендерер
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Освещение
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      // Генерация процедурной карты Wall Street:
      generateCity();

      // Создаем терминал (здание фондовой биржи)
      terminal = createBuilding(3, 6, 3, 0xff0000);
      terminal.position.set(10, 3, -15);
      scene.add(terminal);

      // Создаем игрока: простой персонаж (капа) – используем цилиндр + сфера
      const bodyGeom = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
      const bodyMat = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      body.position.y = 1;

      const headGeom = new THREE.SphereGeometry(0.5, 8, 8);
      const headMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
      const head = new THREE.Mesh(headGeom, headMat);
      head.position.y = 2.5;

      player = new THREE.Group();
      player.add(body);
      player.add(head);
      player.position.set(0, 0, 0);
      scene.add(player);

      // Настраиваем камеру, чтобы она следовала за игроком
      // (Простой треккинг-эффект)
      // Создадим объект-мишень, на который будет смотреть камера
      const target = new THREE.Object3D();
      player.add(target);
      target.position.set(0, 2, 0);

      // Обработчики событий
      window.addEventListener('resize', onWindowResize, false);
      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('keyup', onKeyUp, false);
      // Для мобильных устройств: слушаем касания
      document.addEventListener('touchstart', onTouchStart, false);
      document.addEventListener('touchmove', onTouchMove, false);
      document.addEventListener('touchend', onTouchEnd, false);
    }

    function generateCity() {
      // Генерация ряда зданий вдоль улицы
      const buildingMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
      for (let i = -50; i < 50; i += 5) {
        for (let j = -50; j < 50; j += 5) {
          let width = 3 + Math.random() * 2;
          let depth = 3 + Math.random() * 2;
          let height = 5 + Math.random() * 15;
          let geom = new THREE.BoxGeometry(width, height, depth);
          let building = new THREE.Mesh(geom, buildingMaterial.clone());
          building.material.color.setHSL(Math.random(), 0.5, 0.3);
          building.position.set(i, height/2, j);
          scene.add(building);
        }
      }
    }

    function createBuilding(width, height, depth, color) {
      const geom = new THREE.BoxGeometry(width, height, depth);
      const mat = new THREE.MeshLambertMaterial({ color: color });
      const building = new THREE.Mesh(geom, mat);
      return building;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Обработчики клавиатуры
    function onKeyDown(e) {
      keys[e.code] = true;
    }
    function onKeyUp(e) {
      keys[e.code] = false;
    }

    // Обработчики для касаний (простой слайдер)
    let touchX = null, touchY = null;
    function onTouchStart(e) {
      if (e.touches.length == 1) {
        touchX = e.touches[0].pageX;
        touchY = e.touches[0].pageY;
      }
    }
    function onTouchMove(e) {
      if (e.touches.length == 1 && touchX !== null && touchY !== null) {
        let deltaX = e.touches[0].pageX - touchX;
        let deltaY = e.touches[0].pageY - touchY;
        // Простейшее перемещение игрока
        player.position.x += deltaX * 0.01;
        player.position.z += deltaY * 0.01;
        touchX = e.touches[0].pageX;
        touchY = e.touches[0].pageY;
      }
    }
    function onTouchEnd(e) {
      touchX = null;
      touchY = null;
    }

    function animate() {
      requestAnimationFrame(animate);
      if (gamePaused) {
        renderer.render(scene, camera);
        return;
      }
      let delta = clock.getDelta();
      // Обработка клавиш (для настольных устройств)
      if (keys['ArrowLeft']) player.position.x -= moveSpeed * delta;
      if (keys['ArrowRight']) player.position.x += moveSpeed * delta;
      if (keys['ArrowUp']) player.position.z -= moveSpeed * delta;
      if (keys['ArrowDown']) player.position.z += moveSpeed * delta;

      // Простая коллизия с терминалом: если расстояние < 2, запускаем мини-игру
      if (player.position.distanceTo(terminal.position) < 2) {
        // Запускаем мини-игру, если игрок нажал пробел (на десктопе) или коснулся терминала (на мобильном)
        if (keys['Space']) {
          triggerMinigame();
          keys['Space'] = false;
        }
      }

      // Камера следует за игроком: позиционируем её позади и выше
      camera.position.lerp(new THREE.Vector3(
        player.position.x,
        player.position.y + 5,
        player.position.z + 10
      ), 0.1);
      camera.lookAt(player.position);

      renderer.render(scene, camera);
    }

    // Функция, вызываемая при столкновении с терминалом
    function triggerMinigame() {
      gamePaused = true;
      generateCandlestickChart();
      document.getElementById('minigame-overlay').style.display = "flex";
    }

    // Генерация случайного графика свечей для UJO/USD
    function generateCandlestickChart() {
      let candles = [];
      let price = Math.random() * 50 + 100;
      for (let i = 0; i < 30; i++) {
        let open = price;
        let close = open + (Math.random() - 0.5) * 10;
        let high = Math.max(open, close) + Math.random() * 5;
        let low = Math.min(open, close) - Math.random() * 5;
        candles.push({ open, close, high, low });
        price = close;
      }
      drawCandlestickChart(candles);
    }

    function drawCandlestickChart(candles) {
      const canvas = document.getElementById('chartCanvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let prices = [];
      candles.forEach(c => { prices.push(c.open, c.close, c.high, c.low); });
      let minPrice = Math.min(...prices);
      let maxPrice = Math.max(...prices);
      let scale = canvas.height / (maxPrice - minPrice);
      let candleWidth = canvas.width / candles.length;
      candles.forEach((c, i) => {
        let x = i * candleWidth;
        let highY = canvas.height - (c.high - minPrice) * scale;
        let lowY = canvas.height - (c.low - minPrice) * scale;
        ctx.strokeStyle = "white";
        ctx.beginPath();
        ctx.moveTo(x + candleWidth/2, highY);
        ctx.lineTo(x + candleWidth/2, lowY);
        ctx.stroke();
        let openY = canvas.height - (c.open - minPrice) * scale;
        let closeY = canvas.height - (c.close - minPrice) * scale;
        ctx.fillStyle = c.close >= c.open ? "green" : "red";
        let top = Math.min(openY, closeY);
        let height = Math.abs(openY - closeY);
        if (height < 1) height = 1;
        ctx.fillRect(x, top, candleWidth * 0.8, height);
      });
    }

    // Отправка угадывания направления на сервер
    function submitGuess(guess) {
      let formData = new FormData();
      formData.append('direction', guess);
      let csrfToken = document.querySelector('meta[name="csrf-token"]') ? document.querySelector('meta[name="csrf-token"]').getAttribute('content') : '';
      fetch('/game/api/guess_direction', {
        method: 'POST',
        headers: { 'X-CSRFToken': csrfToken },
        body: formData
      })
      .then(response => response.json())
      .then(data => {
        alert("Result: " + data.result.toUpperCase() + ". Your points: " + data.weekly_points);
        document.getElementById('minigame-overlay').style.display = "none";
        gamePaused = false;
      })
      .catch(err => {
        alert("Error submitting guess.");
        document.getElementById('minigame-overlay').style.display = "none";
        gamePaused = false;
      });
    }

    document.getElementById('btnUp').addEventListener('click', () => submitGuess('up'));
    document.getElementById('btnDown').addEventListener('click', () => submitGuess('down'));
  </script>
</body>
</html>
