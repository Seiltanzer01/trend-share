<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wall Street 3D Platformer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #e0e0e0; /* Светлый фон */
      font-family: 'Press Start 2P', cursive;
    }
    #game-container {
      width: 100%;
      height: 100vh;
      position: relative;
    }
    /* Оверлей мини-игры (график свечей и управление) */
    #minigame-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      z-index: 50;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
    }
    #minigame-overlay canvas {
      border: 2px solid #fff;
      margin-bottom: 20px;
    }
    .minigame-btn {
      padding: 10px 20px;
      margin: 5px;
      background: #27ae60;
      border: none;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
    }
    .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 0, 0, 0.8);
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      padding: 5px 10px;
      border-radius: 50%;
      z-index: 55;
    }
    /* Окно с очками – правый верхний угол */
    #points-window {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid #000;
      padding: 10px;
      color: #000;
      font-size: 16px;
      z-index: 55;
      border-radius: 8px;
    }
    /* Контейнер для виртуального джойстика – левый нижний угол */
    #joystick-container {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 55;
    }
    /* Кнопка выхода из игры – левый верхний угол */
    #exit-game-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 55;
      padding: 8px 12px;
      background: rgba(255, 0, 0, 0.8);
      border: none;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
    }
    /* Кнопка "Talk" для NPC – появляется в нижней части по центру */
    #talk-btn {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 55;
      padding: 10px 20px;
      background: rgba(0, 0, 255, 0.8);
      border: none;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
      display: none;
    }
  </style>
  <!-- Подключаем Three.js, GLTFLoader, NippleJS и Cannon‑ES -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.7.3/nipplejs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
</head>
<body>
  <!-- Кнопка выхода из игры -->
  <button id="exit-game-btn">Exit Game</button>
  <!-- Кнопка "Talk" для NPC -->
  <button id="talk-btn">Talk with Uncle John</button>
  
  <div id="game-container"></div>
  
  <!-- Окно с очками -->
  <div id="points-window">Points: <span id="points-value">0</span></div>
  
  <!-- Контейнер для виртуального джойстика -->
  <div id="joystick-container"></div>
  
  <!-- Оверлей мини-игры (график свечей) -->
  <div id="minigame-overlay">
    <button class="close-btn" id="close-overlay">&times;</button>
    <h2>Guess the Market Direction!</h2>
    <canvas id="chartCanvas" width="300" height="200"></canvas>
    <div>
      <button class="minigame-btn" id="btnUp">UP</button>
      <button class="minigame-btn" id="btnDown">DOWN</button>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Глобальные переменные
      let scene, camera, renderer, clock;
      let world; // Физический мир Cannon‑ES
      let playerMesh, cityMesh, terminalMesh, npcMesh;
      let playerBody;  // Физическое тело игрока
      let moveSpeed = 8;      // Скорость перемещения (увеличена)
      let jumpSpeed = 6;      // Скорость прыжка
      let gravity = -9.8;     // Гравитация (м/с²)
      let isJumping = false;
      let joystickData = null;
      let gamePaused = false;
      let points = 0;
      let keys = {};
      let previousTime = performance.now();
      let cameraRotationOffset = 0;  // горизонтальный поворот (yaw)
      let cameraPitchOffset = 0;     // вертикальный поворот (pitch)
      const mapBounds = { minX: -50, maxX: 50, minZ: -50, maxZ: 50 };

      init();
      animate();

      function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xffffff, 20, 200);

        // Инициализация камеры с возможностью изменять угол обзора
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.set(0, 5, 12);

        // Рендерер
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Физический мир Cannon‑ES с фиксированным временным шагом
        world = new CANNON.World({
          gravity: new CANNON.Vec3(0, gravity, 0)
        });
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Освещение
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const loader = new THREE.GLTFLoader();

        // Загрузка модели города (основная карта)
        loader.load('/static/models/wall_street_city.glb', function(gltf) {
          cityMesh = gltf.scene;
          cityMesh.scale.set(1, 1, 1);
          cityMesh.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              child.material.side = THREE.DoubleSide;
              // Вычисляем bounding box и создаём статические физические тела
              child.geometry.computeBoundingBox();
              let bbox = child.geometry.boundingBox;
              let size = new THREE.Vector3();
              bbox.getSize(size);
              let shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
              child.updateMatrixWorld();
              let pos = new THREE.Vector3();
              pos.setFromMatrixPosition(child.matrixWorld);
              let body = new CANNON.Body({ mass: 0 });
              body.addShape(shape);
              body.position.copy(new CANNON.Vec3(pos.x, pos.y, pos.z));
              world.addBody(body);
            }
          });
          scene.add(cityMesh);
        }, undefined, function(error) {
          console.error('Error loading city model:', error);
        });

        // Загрузка модели терминала (две башни) – размещаем отдельно от карты
        loader.load('/static/models/terminal.glb', function(gltf) {
          terminalMesh = gltf.scene;
          terminalMesh.scale.set(1, 1, 1);
          terminalMesh.position.set(25, 0, -40);
          terminalMesh.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              let bbox = new THREE.Box3().setFromObject(child);
              let size = new THREE.Vector3();
              bbox.getSize(size);
              let shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
              child.updateMatrixWorld();
              let pos = new THREE.Vector3();
              pos.setFromMatrixPosition(child.matrixWorld);
              let body = new CANNON.Body({ mass: 0 });
              body.addShape(shape);
              body.position.copy(new CANNON.Vec3(pos.x, pos.y, pos.z));
              world.addBody(body);
            }
          });
          scene.add(terminalMesh);
        }, undefined, function(error) {
          console.error('Error loading terminal model:', error);
        });

        // Загрузка модели персонажа (игрока)
        loader.load('/static/models/character.glb', function(gltf) {
          playerMesh = gltf.scene;
          playerMesh.scale.set(1.2, 1.2, 1.2);
          // Корректируем позицию так, чтобы модель была полностью видна
          playerMesh.position.set(-10, 0, 10);
          playerMesh.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              child.material.side = THREE.DoubleSide;
            }
          });
          scene.add(playerMesh);
          // Создаем физическое тело для игрока на основе bounding box модели
          let box = new THREE.Box3().setFromObject(playerMesh);
          let size = new THREE.Vector3();
          box.getSize(size);
          let shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
          playerBody = new CANNON.Body({ mass: 1 });
          playerBody.addShape(shape);
          playerBody.position.copy(playerMesh.position);
          playerBody.fixedRotation = true;
          playerBody.updateMassProperties();
          world.addBody(playerBody);
        }, undefined, function(error) {
          console.error('Error loading character model:', error);
          // Фолбэк: простой куб
          const geometry = new THREE.BoxGeometry(1, 2, 1);
          const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
          playerMesh = new THREE.Mesh(geometry, material);
          playerMesh.position.set(-10, 1, 10);
          scene.add(playerMesh);
          let shape = new CANNON.Box(new CANNON.Vec3(0.5, 1, 0.5));
          playerBody = new CANNON.Body({ mass: 1 });
          playerBody.addShape(shape);
          playerBody.position.copy(playerMesh.position);
          playerBody.fixedRotation = true;
          world.addBody(playerBody);
        });

        // Загрузка модели NPC "Дядя Джон"
        loader.load('/static/models/uncle_john.glb', function(gltf) {
          npcMesh = gltf.scene;
          npcMesh.scale.set(1, 1, 1);
          // Размещаем NPC рядом с терминалом – если терминал уже загружен, используем его позицию, иначе задаём по умолчанию
          npcMesh.position.set(terminalMesh ? terminalMesh.position.x - 5 : 20, 0, terminalMesh ? terminalMesh.position.z + 5 : -25);
          npcMesh.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(npcMesh);
          // Добавляем статическое физическое тело для NPC
          let bbox = new THREE.Box3().setFromObject(npcMesh);
          let size = new THREE.Vector3();
          bbox.getSize(size);
          let shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
          npcMesh.updateMatrixWorld();
          let pos = new THREE.Vector3();
          pos.setFromMatrixPosition(npcMesh.matrixWorld);
          let body = new CANNON.Body({ mass: 0 });
          body.addShape(shape);
          body.position.copy(new CANNON.Vec3(pos.x, pos.y, pos.z));
          world.addBody(body);
        }, undefined, function(error) {
          console.error('Error loading NPC model:', error);
        });

        // Настройка виртуального джойстика (режим dynamic для мобильных устройств)
        joystick = nipplejs.create({
          zone: document.getElementById('joystick-container'),
          mode: 'dynamic',
          color: 'white',
          size: 100
        });
        joystick.on('move', function(evt, data) {
          if (data && data.angle) {
            joystickData = data;
          }
        });
        joystick.on('end', function() {
          joystickData = null;
        });

        // Обработка касаний для поворота обзора (один палец: горизонтально и вертикально)
        let touchStartX = null, touchStartY = null;
        document.addEventListener('touchstart', function(e) {
          if (e.touches.length === 1) {
            touchStartX = e.touches[0].pageX;
            touchStartY = e.touches[0].pageY;
          }
        }, false);
        document.addEventListener('touchmove', function(e) {
          if (e.touches.length === 1 && touchStartX !== null && touchStartY !== null) {
            let deltaX = e.touches[0].pageX - touchStartX;
            let deltaY = e.touches[0].pageY - touchStartY;
            cameraRotationOffset += deltaX * 0.005;
            cameraPitchOffset = Math.max(-Math.PI/4, Math.min(Math.PI/4, cameraPitchOffset + deltaY * 0.005));
            touchStartX = e.touches[0].pageX;
            touchStartY = e.touches[0].pageY;
          }
        }, false);

        // Интерфейсные кнопки
        document.getElementById('close-overlay').addEventListener('click', function() {
          document.getElementById('minigame-overlay').style.display = "none";
          gamePaused = false;
        });
        document.getElementById('exit-game-btn').addEventListener('click', function() {
          window.location.href = '/';
        });
        document.getElementById('talk-btn').addEventListener('click', function() {
          alert("You are now talking with Uncle John. Press OK to start the mini-game!");
          triggerMinigame();
          document.getElementById('talk-btn').style.display = "none";
        });

        window.addEventListener('resize', onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        let currentTime = performance.now();
        let delta = (currentTime - previousTime) / 1000;
        previousTime = currentTime;
        requestAnimationFrame(animate);

        // Шаг физического мира с фиксированным временным шагом
        const fixedTimeStep = 1.0 / 60.0;
        world.step(fixedTimeStep, delta, 10);

        if (!gamePaused && playerBody) {
          // Синхронизируем позицию модели с физическим телом
          playerMesh.position.copy(playerBody.position);
          playerMesh.quaternion.copy(playerBody.quaternion);

          // Управление по данным джойстика (для мобильных устройств)
          if (joystickData) {
            let rad = THREE.Math.degToRad(joystickData.angle.degree);
            let factor = (joystickData.distance / 50) * moveSpeed;
            // Устанавливаем горизонтальную скорость через физическое тело
            playerBody.velocity.x = Math.cos(rad) * factor;
            playerBody.velocity.z = -Math.sin(rad) * factor;
          } else {
            // Если нет ввода, плавно сбрасываем скорость
            playerBody.velocity.x *= 0.9;
            playerBody.velocity.z *= 0.9;
          }
          // Обработка клавиатуры (для десктопа)
          if (keys['ArrowLeft']) playerBody.velocity.x = -moveSpeed;
          if (keys['ArrowRight']) playerBody.velocity.x = moveSpeed;
          if (keys['ArrowUp']) playerBody.velocity.z = -moveSpeed;
          if (keys['ArrowDown']) playerBody.velocity.z = moveSpeed;

          // Прыжок (Space)
          if (keys['Space'] && !isJumping) {
            playerBody.velocity.y = jumpSpeed;
            isJumping = true;
          }
          if (isJumping) {
            if (playerBody.position.y <= 0.5) {
              isJumping = false;
              playerBody.velocity.y = 0;
            }
          }

          // Ограничение движения в пределах карты
          playerBody.position.x = Math.max(mapBounds.minX, Math.min(mapBounds.maxX, playerBody.position.x));
          playerBody.position.z = Math.max(mapBounds.minZ, Math.min(mapBounds.maxZ, playerBody.position.z));

          // Коллизии с объектами (физика обрабатывает столкновения с телами, созданными для cityMesh и terminalMesh)

          // Если игрок рядом с NPC, показываем кнопку Talk
          if (npcMesh) {
            let distNPC = playerMesh.position.distanceTo(npcMesh.position);
            let talkBtn = document.getElementById('talk-btn');
            if (distNPC < 4) {
              talkBtn.style.display = "block";
            } else {
              talkBtn.style.display = "none";
            }
          }
        }

        // Обновляем камеру: плавное следование за игроком с учетом горизонтального (yaw) и вертикального (pitch) обзора
        if (playerMesh) {
          let desiredPosition = new THREE.Vector3(
            playerMesh.position.x,
            playerMesh.position.y + 5,
            playerMesh.position.z + 10
          );
          let offset = new THREE.Vector3().subVectors(desiredPosition, playerMesh.position);
          offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraRotationOffset);
          desiredPosition = new THREE.Vector3().addVectors(playerMesh.position, offset);
          camera.position.lerp(desiredPosition, 0.1);
          camera.rotation.x = -cameraPitchOffset;
          camera.lookAt(playerMesh.position);
        }
        
        renderer.render(scene, camera);
      }

      // Клавиатурные обработчики (для десктопа)
      document.addEventListener('keydown', (e) => { keys[e.code] = true; });
      document.addEventListener('keyup', (e) => { keys[e.code] = false; });

      // Функции мини-игры (генерация графика свечей)
      function generateCandlestickChart() {
        let candles = [];
        let price = Math.random() * 50 + 100;
        for (let i = 0; i < 30; i++) {
          let open = price;
          let close = open + (Math.random() - 0.5) * 10;
          let high = Math.max(open, close) + Math.random() * 5;
          let low = Math.min(open, close) - Math.random() * 5;
          candles.push({ open, close, high, low });
          price = close;
        }
        drawCandlestickChart(candles);
      }

      function drawCandlestickChart(candles) {
        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let prices = [];
        candles.forEach(c => { prices.push(c.open, c.close, c.high, c.low); });
        let minPrice = Math.min(...prices);
        let maxPrice = Math.max(...prices);
        let scale = canvas.height / (maxPrice - minPrice);
        let candleWidth = canvas.width / candles.length;
        candles.forEach((c, i) => {
          let x = i * candleWidth;
          let highY = canvas.height - (c.high - minPrice) * scale;
          let lowY = canvas.height - (c.low - minPrice) * scale;
          ctx.strokeStyle = "white";
          ctx.beginPath();
          ctx.moveTo(x + candleWidth/2, highY);
          ctx.lineTo(x + candleWidth/2, lowY);
          ctx.stroke();
          let openY = canvas.height - (c.open - minPrice) * scale;
          let closeY = canvas.height - (c.close - minPrice) * scale;
          ctx.fillStyle = c.close >= c.open ? "green" : "red";
          let top = Math.min(openY, closeY);
          let height = Math.abs(openY - closeY);
          if (height < 1) height = 1;
          ctx.fillRect(x, top, candleWidth * 0.8, height);
        });
      }

      // Функция запуска мини-игры (остановка симуляции и показ оверлея)
      function triggerMinigame() {
        gamePaused = true;
        generateCandlestickChart();
        document.getElementById('minigame-overlay').style.display = "flex";
      }

      // Отправка результата мини-игры на сервер
      function submitGuess(guess) {
        let formData = new FormData();
        formData.append('direction', guess);
        let csrfToken = document.querySelector('meta[name="csrf-token"]') ?
                        document.querySelector('meta[name="csrf-token"]').getAttribute('content') : '';
        fetch('/game/api/guess_direction', {
          method: 'POST',
          headers: { 'X-CSRFToken': csrfToken },
          body: formData
        })
        .then(response => response.json())
        .then(data => {
          alert("Result: " + data.result.toUpperCase() + ". Your points: " + data.weekly_points);
          document.getElementById('points-value').innerText = data.weekly_points;
          document.getElementById('minigame-overlay').style.display = "none";
          gamePaused = false;
        })
        .catch(err => {
          alert("Error submitting guess.");
          document.getElementById('minigame-overlay').style.display = "none";
          gamePaused = false;
        });
      }

      document.getElementById('btnUp').addEventListener('click', () => submitGuess('up'));
      document.getElementById('btnDown').addEventListener('click', () => submitGuess('down'));
    });
  </script>
</body>
</html>
