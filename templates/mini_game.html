<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wall Street 3D Platformer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #e0e0e0; /* Светлый фон */
      font-family: 'Press Start 2P', cursive;
    }
    #game-container {
      width: 100%;
      height: 100vh;
      position: relative;
    }
    /* Оверлей мини-игры (график свечей и управление) */
    #minigame-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      z-index: 50;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
    }
    #minigame-overlay canvas {
      border: 2px solid #fff;
      margin-bottom: 20px;
    }
    .minigame-btn {
      padding: 10px 20px;
      margin: 5px;
      background: #27ae60;
      border: none;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
    }
    .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 0, 0, 0.8);
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      padding: 5px 10px;
      border-radius: 50%;
      z-index: 55;
    }
    /* Окно с очками – правый верхний угол */
    #points-window {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid #000;
      padding: 10px;
      color: #000;
      font-size: 16px;
      z-index: 55;
      border-radius: 8px;
    }
    /* Контейнер для виртуального джойстика – левый нижний угол */
    #joystick-container {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 55;
    }
    /* Кнопка выхода из игры – левый верхний угол */
    #exit-game-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 55;
      padding: 8px 12px;
      background: rgba(255, 0, 0, 0.8);
      border: none;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
    }
    /* Кнопка "Talk" для NPC – появляется в нижней части по центру */
    #talk-btn {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 55;
      padding: 10px 20px;
      background: rgba(0, 0, 255, 0.8);
      border: none;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
      display: none;
    }
  </style>
  <!-- Подключаем Three.js, GLTFLoader и NippleJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.7.3/nipplejs.min.js"></script>
</head>
<body>
  <!-- Кнопка выхода из игры -->
  <button id="exit-game-btn">Exit Game</button>
  <!-- Кнопка "Talk" для NPC -->
  <button id="talk-btn">Talk with Uncle John</button>
  
  <div id="game-container"></div>
  
  <!-- Окно с очками -->
  <div id="points-window">Points: <span id="points-value">0</span></div>
  
  <!-- Контейнер для виртуального джойстика -->
  <div id="joystick-container"></div>
  
  <!-- Оверлей мини-игры (график свечей) -->
  <div id="minigame-overlay">
    <button class="close-btn" id="close-overlay">&times;</button>
    <h2>Guess the Market Direction!</h2>
    <canvas id="chartCanvas" width="300" height="200"></canvas>
    <div>
      <button class="minigame-btn" id="btnUp">UP</button>
      <button class="minigame-btn" id="btnDown">DOWN</button>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Глобальные переменные
      let scene, camera, renderer, clock;
      let player, city, terminal, npc;
      let moveSpeed = 8; // увеличенная скорость
      let jumpSpeed = 6; // скорость прыжка
      let gravity = 9.8;
      let velocityY = 0;
      let isJumping = false;
      let joystickData = null; // данные от джойстика
      let gamePaused = false;
      let points = 0;
      let keys = {};
      let previousTime = performance.now();
      let cameraRotationOffset = 0; // для поворота обзора

      // Ограничения карты (границы координат)
      const mapBounds = { minX: -50, maxX: 50, minZ: -50, maxZ: 50 };

      // Инициализация Three.js
      init();
      animate();

      function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xffffff, 20, 200);  // светлый мир

        // Камера от третьего лица
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 1000);
        camera.position.set(0, 5, 12);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Освещение
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const loader = new THREE.GLTFLoader();

        // Загрузка модели города
        loader.load('/static/models/wall_street_city.glb', function(gltf) {
          city = gltf.scene;
          city.scale.set(1, 1, 1);
          city.traverse(function(child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(city);
        }, undefined, function(error) {
          console.error('Error loading city model:', error);
        });

        // Загрузка модели терминала (две башни)
        loader.load('/static/models/terminal.glb', function(gltf) {
          terminal = gltf.scene;
          terminal.scale.set(1, 1, 1);
          // Размещаем терминал в стороне от улицы
          terminal.position.set(25, 0, -30);
          terminal.traverse(function(child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(terminal);
        }, undefined, function(error) {
          console.error('Error loading terminal model:', error);
        });

        // Загрузка модели персонажа (игрока)
        loader.load('/static/models/character.glb', function(gltf) {
          player = gltf.scene;
          // Увеличиваем масштаб и корректируем позицию, чтобы вся модель была видна
          player.scale.set(1.2, 1.2, 1.2);
          // Располагаем игрока немного от терминала
          player.position.set(-10, 0, 10);
          player.traverse(function(child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              // Используем обе стороны материала, чтобы текстуры корректно отображались
              if(child.material) child.material.side = THREE.DoubleSide;
            }
          });
          scene.add(player);
        }, undefined, function(error) {
          console.error('Error loading character model:', error);
          // Фолбэк: простой куб
          const geometry = new THREE.BoxGeometry(1, 2, 1);
          const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
          player = new THREE.Mesh(geometry, material);
          player.position.set(-10, 1, 10);
          scene.add(player);
        });

        // Загрузка модели NPC "Дядя Джон"
        loader.load('/static/models/uncle_john.glb', function(gltf) {
          npc = gltf.scene;
          npc.scale.set(1, 1, 1);
          // Размещаем NPC рядом с терминалом, но не слишком близко, чтобы игрок мог подойти и начать диалог
          npc.position.set(terminal ? terminal.position.x - 5 : 20, 0, terminal ? terminal.position.z + 5 : -25);
          npc.traverse(function(child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(npc);
        }, undefined, function(error) {
          console.error('Error loading NPC model:', error);
        });

        // Настройка виртуального джойстика для мобильных устройств (dynamic режим для лучшей адаптации)
        joystick = nipplejs.create({
          zone: document.getElementById('joystick-container'),
          mode: 'dynamic',
          color: 'white',
          size: 100
        });
        joystick.on('move', function (evt, data) {
          if (data && data.angle) {
            joystickData = data;
          }
        });
        joystick.on('end', function () {
          joystickData = null;
        });

        // Обработка касаний для поворота обзора (один палец)
        let touchStartX = null;
        document.addEventListener('touchstart', function(e) {
          if (e.touches.length === 1) {
            touchStartX = e.touches[0].pageX;
          }
        }, false);
        document.addEventListener('touchmove', function(e) {
          if (e.touches.length === 1 && touchStartX !== null) {
            let deltaX = e.touches[0].pageX - touchStartX;
            cameraRotationOffset += deltaX * 0.005;
            touchStartX = e.touches[0].pageX;
          }
        }, false);

        // Кнопка закрытия мини-игры
        document.getElementById('close-overlay').addEventListener('click', function() {
          document.getElementById('minigame-overlay').style.display = "none";
          gamePaused = false;
        });

        // Кнопка выхода из игры -> возвращает на главную страницу
        document.getElementById('exit-game-btn').addEventListener('click', function() {
          window.location.href = '/';
        });

        // Кнопка "Talk" для NPC
        document.getElementById('talk-btn').addEventListener('click', function() {
          alert("You are now talking with Uncle John. Press OK to start the mini-game!");
          triggerMinigame();
          // После начала диалога кнопку скрываем, чтобы не мешала
          document.getElementById('talk-btn').style.display = "none";
        });

        window.addEventListener('resize', onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        let currentTime = performance.now();
        let delta = (currentTime - previousTime) / 1000;  // delta в секундах
        previousTime = currentTime;
        requestAnimationFrame(animate);

        if (!gamePaused && player) {
          // Обновляем движение игрока по данным джойстика (если есть)
          if (joystickData) {
            let rad = THREE.Math.degToRad(joystickData.angle.degree);
            let factor = (joystickData.distance / 50) * moveSpeed;
            player.position.x += Math.cos(rad) * factor * delta;
            player.position.z -= Math.sin(rad) * factor * delta;
          }

          // Обработка клавиатуры (для десктопа)
          if (keys['ArrowLeft']) player.position.x -= moveSpeed * delta;
          if (keys['ArrowRight']) player.position.x += moveSpeed * delta;
          if (keys['ArrowUp']) player.position.z -= moveSpeed * delta;
          if (keys['ArrowDown']) player.position.z += moveSpeed * delta;

          // Обработка прыжка (клавиша Space)
          if (keys['Space'] && !isJumping) {
            velocityY = jumpSpeed;
            isJumping = true;
          }
          if (isJumping) {
            player.position.y += velocityY * delta;
            velocityY -= gravity * delta;
            if (player.position.y <= 0) {
              player.position.y = 0;
              isJumping = false;
              velocityY = 0;
            }
          }

          // Ограничиваем движение игрока внутри карты
          player.position.x = Math.max(mapBounds.minX, Math.min(mapBounds.maxX, player.position.x));
          player.position.z = Math.max(mapBounds.minZ, Math.min(mapBounds.maxZ, player.position.z));

          // Простая коллизия с терминалом: отталкиваем игрока, если слишком близко
          if (terminal) {
            let distTerminal = player.position.distanceTo(terminal.position);
            if (distTerminal < 2) {
              let dir = player.position.clone().sub(terminal.position).normalize();
              player.position.copy(terminal.position.clone().add(dir.multiplyScalar(2)));
            }
          }

          // Если игрок находится рядом с NPC, показываем кнопку "Talk"
          if (npc) {
            let distNPC = player.position.distanceTo(npc.position);
            let talkBtn = document.getElementById('talk-btn');
            if (distNPC < 4) {
              talkBtn.style.display = "block";
            } else {
              talkBtn.style.display = "none";
            }
          }
        }

        // Камера следует за игроком с учётом поворота обзора
        if (player) {
          let desiredPosition = new THREE.Vector3(
            player.position.x,
            player.position.y + 5,
            player.position.z + 10
          );
          // Применяем поворот обзора вокруг оси Y
          let offset = new THREE.Vector3().subVectors(desiredPosition, player.position);
          offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraRotationOffset);
          desiredPosition = new THREE.Vector3().addVectors(player.position, offset);
          camera.position.lerp(desiredPosition, 0.1);
          camera.lookAt(player.position);
        }

        renderer.render(scene, camera);
      }

      // Клавиатурные обработчики (для десктопа)
      document.addEventListener('keydown', (e) => { keys[e.code] = true; });
      document.addEventListener('keyup', (e) => { keys[e.code] = false; });

      // Функция для генерации случайного графика свечей (мини-игра)
      function generateCandlestickChart() {
        let candles = [];
        let price = Math.random() * 50 + 100;
        for (let i = 0; i < 30; i++) {
          let open = price;
          let close = open + (Math.random() - 0.5) * 10;
          let high = Math.max(open, close) + Math.random() * 5;
          let low = Math.min(open, close) - Math.random() * 5;
          candles.push({ open, close, high, low });
          price = close;
        }
        drawCandlestickChart(candles);
      }

      function drawCandlestickChart(candles) {
        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let prices = [];
        candles.forEach(c => { prices.push(c.open, c.close, c.high, c.low); });
        let minPrice = Math.min(...prices);
        let maxPrice = Math.max(...prices);
        let scale = canvas.height / (maxPrice - minPrice);
        let candleWidth = canvas.width / candles.length;
        candles.forEach((c, i) => {
          let x = i * candleWidth;
          let highY = canvas.height - (c.high - minPrice) * scale;
          let lowY = canvas.height - (c.low - minPrice) * scale;
          ctx.strokeStyle = "white";
          ctx.beginPath();
          ctx.moveTo(x + candleWidth/2, highY);
          ctx.lineTo(x + candleWidth/2, lowY);
          ctx.stroke();
          let openY = canvas.height - (c.open - minPrice) * scale;
          let closeY = canvas.height - (c.close - minPrice) * scale;
          ctx.fillStyle = c.close >= c.open ? "green" : "red";
          let top = Math.min(openY, closeY);
          let height = Math.abs(openY - closeY);
          if (height < 1) height = 1;
          ctx.fillRect(x, top, candleWidth * 0.8, height);
        });
      }

      // Функция запуска мини-игры: останавливает основной игровой цикл и показывает оверлей
      function triggerMinigame() {
        gamePaused = true;
        generateCandlestickChart();
        document.getElementById('minigame-overlay').style.display = "flex";
      }

      // Отправка результата мини-игры на сервер
      function submitGuess(guess) {
        let formData = new FormData();
        formData.append('direction', guess);
        let csrfToken = document.querySelector('meta[name="csrf-token"]') ?
                        document.querySelector('meta[name="csrf-token"]').getAttribute('content') : '';
        fetch('/game/api/guess_direction', {
          method: 'POST',
          headers: { 'X-CSRFToken': csrfToken },
          body: formData
        })
        .then(response => response.json())
        .then(data => {
          alert("Result: " + data.result.toUpperCase() + ". Your points: " + data.weekly_points);
          document.getElementById('points-value').innerText = data.weekly_points;
          document.getElementById('minigame-overlay').style.display = "none";
          gamePaused = false;
        })
        .catch(err => {
          alert("Error submitting guess.");
          document.getElementById('minigame-overlay').style.display = "none";
          gamePaused = false;
        });
      }

      document.getElementById('btnUp').addEventListener('click', () => submitGuess('up'));
      document.getElementById('btnDown').addEventListener('click', () => submitGuess('down'));
    });
  </script>
</body>
</html>
