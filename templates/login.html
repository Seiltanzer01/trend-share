@app.route('/telegram_login', methods=['POST'])
def telegram_login():
    """
    Обработчик данных авторизации от Telegram Login Widget.
    Принимает данные через JSON.
    """
    if not request.is_json:
        logger.warning("Некорректный тип запроса. Ожидается JSON.")
        return jsonify({'success': False, 'message': 'Некорректный тип запроса.'}), 400

    data = request.get_json()
    logger.debug(f"Получены данные для авторизации: {data}")

    if not data:
        logger.warning("Отсутствуют данные авторизации.")
        return jsonify({'success': False, 'message': 'Отсутствуют данные для авторизации.'}), 400

    try:
        auth_date = int(data.get('auth_date', 0))
    except ValueError:
        logger.warning("Некорректное значение auth_date.")
        return jsonify({'success': False, 'message': 'Некорректное значение auth_date.'}), 400

    if time.time() - auth_date > 600:
        logger.warning("Время авторизации истекло.")
        return jsonify({'success': False, 'message': 'Время авторизации истекло.'}), 401

    check_hash = data.pop('hash', None)
    if not check_hash:
        logger.warning("Отсутствует hash в данных авторизации.")
        return jsonify({'success': False, 'message': 'Отсутствует hash.'}), 400

    # Создание строки для проверки подписи
    data_check_arr = [f"{k}={v}" for k, v in sorted(data.items())]
    data_check_string = '\n'.join(data_check_arr)
    secret_key = hashlib.sha256(app.config['TELEGRAM_BOT_TOKEN'].encode()).digest()
    hmac_hash = hmac.new(secret_key, data_check_string.encode(), hashlib.sha256).hexdigest()

    logger.debug(f"data_check_string: {data_check_string}")
    logger.debug(f"hmac_hash: {hmac_hash}")
    logger.debug(f"check_hash: {check_hash}")

    if hmac_hash != check_hash:
        logger.warning("Неверная подпись данных.")
        return jsonify({'success': False, 'message': 'Неверная подпись данных.'}), 401

    # Авторизация прошла успешно
    telegram_id = data.get('id')
    username = data.get('username')
    first_name = data.get('first_name')
    last_name = data.get('last_name')

    # Поиск или создание пользователя в базе данных
    user = User.query.filter_by(telegram_id=telegram_id).first()
    if not user:
        user = User(
            telegram_id=telegram_id,
            username=username,
            first_name=first_name,
            last_name=last_name,
            registered_at=datetime.utcnow()
        )
        db.session.add(user)
        db.session.commit()
        logger.info(f"Новый пользователь создан: Telegram ID {telegram_id}.")

    # Установка сессии пользователя
    session['user_id'] = user.id
    session['telegram_id'] = user.telegram_id

    logger.info(f"Пользователь ID {user.id} (Telegram ID {telegram_id}) авторизовался через Telegram.")
    logger.debug(f"Текущая сессия: {session}")

    # Возвращаем правильный формат ответа для Telegram WebApp
    return jsonify({'url': url_for('index', _external=True)}), 200
